{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n} // This is a legacy function.\n// Use `findNumbers()` instead.\n\n\nimport { PLUS_CHARS, VALID_PUNCTUATION, VALID_DIGITS, WHITESPACE } from './constants';\nimport parse from './parse_';\nimport { VALID_PHONE_NUMBER_WITH_EXTENSION } from './helpers/isViablePhoneNumber';\nimport createExtensionPattern from './helpers/extension/createExtensionPattern';\nimport parsePreCandidate from './findNumbers/parsePreCandidate';\nimport isValidPreCandidate from './findNumbers/isValidPreCandidate';\nimport isValidCandidate from './findNumbers/isValidCandidate';\n/**\r\n * Regexp of all possible ways to write extensions, for use when parsing. This\r\n * will be run as a case-insensitive regexp match. Wide character versions are\r\n * also provided after each ASCII version. There are three regular expressions\r\n * here. The first covers RFC 3966 format, where the extension is added using\r\n * ';ext='. The second more generic one starts with optional white space and\r\n * ends with an optional full stop (.), followed by zero or more spaces/tabs\r\n * /commas and then the numbers themselves. The other one covers the special\r\n * case of American numbers where the extension is written with a hash at the\r\n * end, such as '- 503#'. Note that the only capturing groups should be around\r\n * the digits that you want to capture as part of the extension, or else parsing\r\n * will fail! We allow two options for representing the accented o - the\r\n * character itself, and one in the unicode decomposed form with the combining\r\n * acute accent.\r\n */\n\nexport var EXTN_PATTERNS_FOR_PARSING = createExtensionPattern('parsing');\nvar WHITESPACE_IN_THE_BEGINNING_PATTERN = new RegExp('^[' + WHITESPACE + ']+');\nvar PUNCTUATION_IN_THE_END_PATTERN = new RegExp('[' + VALID_PUNCTUATION + ']+$'); // // Regular expression for getting opening brackets for a valid number\n// // found using `PHONE_NUMBER_START_PATTERN` for prepending those brackets to the number.\n// const BEFORE_NUMBER_DIGITS_PUNCTUATION = new RegExp('[' + OPENING_BRACKETS + ']+' + '[' + WHITESPACE + ']*' + '$')\n\nvar VALID_PRECEDING_CHARACTER_PATTERN = /[^a-zA-Z0-9]/;\nexport default function findPhoneNumbers(text, options, metadata) {\n  /* istanbul ignore if */\n  if (options === undefined) {\n    options = {};\n  }\n\n  var search = new PhoneNumberSearch(text, options, metadata);\n  var phones = [];\n\n  while (search.hasNext()) {\n    phones.push(search.next());\n  }\n\n  return phones;\n}\n/**\r\n * @return ES6 `for ... of` iterator.\r\n */\n\nexport function searchPhoneNumbers(text, options, metadata) {\n  /* istanbul ignore if */\n  if (options === undefined) {\n    options = {};\n  }\n\n  var search = new PhoneNumberSearch(text, options, metadata);\n  return _defineProperty({}, Symbol.iterator, function () {\n    return {\n      next: function next() {\n        if (search.hasNext()) {\n          return {\n            done: false,\n            value: search.next()\n          };\n        }\n\n        return {\n          done: true\n        };\n      }\n    };\n  });\n}\n/**\r\n * Extracts a parseable phone number including any opening brackets, etc.\r\n * @param  {string} text - Input.\r\n * @return {object} `{ ?number, ?startsAt, ?endsAt }`.\r\n */\n\nexport var PhoneNumberSearch = /*#__PURE__*/function () {\n  // Iteration tristate.\n  function PhoneNumberSearch(text, options, metadata) {\n    _classCallCheck(this, PhoneNumberSearch);\n\n    _defineProperty(this, \"state\", 'NOT_READY');\n\n    this.text = text; // If assigning the `{}` default value is moved to the arguments above,\n    // code coverage would decrease for some weird reason.\n\n    this.options = options || {};\n    this.metadata = metadata;\n    this.regexp = new RegExp(VALID_PHONE_NUMBER_WITH_EXTENSION, 'ig');\n  }\n\n  _createClass(PhoneNumberSearch, [{\n    key: \"find\",\n    value: function find() {\n      var matches = this.regexp.exec(this.text);\n\n      if (!matches) {\n        return;\n      }\n\n      var number = matches[0];\n      var startsAt = matches.index;\n      number = number.replace(WHITESPACE_IN_THE_BEGINNING_PATTERN, '');\n      startsAt += matches[0].length - number.length; // Fixes not parsing numbers with whitespace in the end.\n      // Also fixes not parsing numbers with opening parentheses in the end.\n      // https://github.com/catamphetamine/libphonenumber-js/issues/252\n\n      number = number.replace(PUNCTUATION_IN_THE_END_PATTERN, '');\n      number = parsePreCandidate(number);\n      var result = this.parseCandidate(number, startsAt);\n\n      if (result) {\n        return result;\n      } // Tail recursion.\n      // Try the next one if this one is not a valid phone number.\n\n\n      return this.find();\n    }\n  }, {\n    key: \"parseCandidate\",\n    value: function parseCandidate(number, startsAt) {\n      if (!isValidPreCandidate(number, startsAt, this.text)) {\n        return;\n      } // Don't parse phone numbers which are non-phone numbers\n      // due to being part of something else (e.g. a UUID).\n      // https://github.com/catamphetamine/libphonenumber-js/issues/213\n      // Copy-pasted from Google's `PhoneNumberMatcher.js` (`.parseAndValidate()`).\n\n\n      if (!isValidCandidate(number, startsAt, this.text, this.options.extended ? 'POSSIBLE' : 'VALID')) {\n        return;\n      } // // Prepend any opening brackets left behind by the\n      // // `PHONE_NUMBER_START_PATTERN` regexp.\n      // const text_before_number = text.slice(this.searching_from, startsAt)\n      // const full_number_starts_at = text_before_number.search(BEFORE_NUMBER_DIGITS_PUNCTUATION)\n      // if (full_number_starts_at >= 0)\n      // {\n      // \tnumber   = text_before_number.slice(full_number_starts_at) + number\n      // \tstartsAt = full_number_starts_at\n      // }\n      //\n      // this.searching_from = matches.lastIndex\n\n\n      var result = parse(number, this.options, this.metadata);\n\n      if (!result.phone) {\n        return;\n      }\n\n      result.startsAt = startsAt;\n      result.endsAt = startsAt + number.length;\n      return result;\n    }\n  }, {\n    key: \"hasNext\",\n    value: function hasNext() {\n      if (this.state === 'NOT_READY') {\n        this.last_match = this.find();\n\n        if (this.last_match) {\n          this.state = 'READY';\n        } else {\n          this.state = 'DONE';\n        }\n      }\n\n      return this.state === 'READY';\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      // Check the state and find the next match as a side-effect if necessary.\n      if (!this.hasNext()) {\n        throw new Error('No next element');\n      } // Don't retain that memory any longer than necessary.\n\n\n      var result = this.last_match;\n      this.last_match = null;\n      this.state = 'NOT_READY';\n      return result;\n    }\n  }]);\n\n  return PhoneNumberSearch;\n}();","map":{"version":3,"sources":["../source/findPhoneNumbers_.js"],"names":["EXTN_PATTERNS_FOR_PARSING","createExtensionPattern","WHITESPACE_IN_THE_BEGINNING_PATTERN","PUNCTUATION_IN_THE_END_PATTERN","VALID_PRECEDING_CHARACTER_PATTERN","options","search","phones","Symbol","next","done","value","PhoneNumberSearch","matches","number","startsAt","parsePreCandidate","result","isValidPreCandidate","isValidCandidate","parse"],"mappings":"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","sourcesContent":["// This is a legacy function.\r\n// Use `findNumbers()` instead.\r\n\r\nimport {\r\n\tPLUS_CHARS,\r\n\tVALID_PUNCTUATION,\r\n\tVALID_DIGITS,\r\n\tWHITESPACE\r\n} from './constants'\r\n\r\nimport parse from './parse_'\r\nimport { VALID_PHONE_NUMBER_WITH_EXTENSION } from './helpers/isViablePhoneNumber'\r\nimport createExtensionPattern from './helpers/extension/createExtensionPattern'\r\n\r\nimport parsePreCandidate from './findNumbers/parsePreCandidate'\r\nimport isValidPreCandidate from './findNumbers/isValidPreCandidate'\r\nimport isValidCandidate from './findNumbers/isValidCandidate'\r\n\r\n/**\r\n * Regexp of all possible ways to write extensions, for use when parsing. This\r\n * will be run as a case-insensitive regexp match. Wide character versions are\r\n * also provided after each ASCII version. There are three regular expressions\r\n * here. The first covers RFC 3966 format, where the extension is added using\r\n * ';ext='. The second more generic one starts with optional white space and\r\n * ends with an optional full stop (.), followed by zero or more spaces/tabs\r\n * /commas and then the numbers themselves. The other one covers the special\r\n * case of American numbers where the extension is written with a hash at the\r\n * end, such as '- 503#'. Note that the only capturing groups should be around\r\n * the digits that you want to capture as part of the extension, or else parsing\r\n * will fail! We allow two options for representing the accented o - the\r\n * character itself, and one in the unicode decomposed form with the combining\r\n * acute accent.\r\n */\r\nexport const EXTN_PATTERNS_FOR_PARSING = createExtensionPattern('parsing')\r\n\r\nconst WHITESPACE_IN_THE_BEGINNING_PATTERN = new RegExp('^[' + WHITESPACE + ']+')\r\nconst PUNCTUATION_IN_THE_END_PATTERN = new RegExp('[' + VALID_PUNCTUATION + ']+$')\r\n\r\n// // Regular expression for getting opening brackets for a valid number\r\n// // found using `PHONE_NUMBER_START_PATTERN` for prepending those brackets to the number.\r\n// const BEFORE_NUMBER_DIGITS_PUNCTUATION = new RegExp('[' + OPENING_BRACKETS + ']+' + '[' + WHITESPACE + ']*' + '$')\r\n\r\nconst VALID_PRECEDING_CHARACTER_PATTERN = /[^a-zA-Z0-9]/\r\n\r\nexport default function findPhoneNumbers(text, options, metadata) {\r\n\t/* istanbul ignore if */\r\n\tif (options === undefined) {\r\n\t\toptions = {}\r\n\t}\r\n\tconst search = new PhoneNumberSearch(text, options, metadata)\r\n\tconst phones = []\r\n\twhile (search.hasNext()) {\r\n\t\tphones.push(search.next())\r\n\t}\r\n\treturn phones\r\n}\r\n\r\n/**\r\n * @return ES6 `for ... of` iterator.\r\n */\r\nexport function searchPhoneNumbers(text, options, metadata) {\r\n\t/* istanbul ignore if */\r\n\tif (options === undefined) {\r\n\t\toptions = {}\r\n\t}\r\n\tconst search = new PhoneNumberSearch(text, options, metadata)\r\n\treturn  {\r\n\t\t[Symbol.iterator]() {\r\n\t\t\treturn {\r\n\t    \t\tnext: () => {\r\n\t    \t\t\tif (search.hasNext()) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tdone: false,\r\n\t\t\t\t\t\t\tvalue: search.next()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tdone: true\r\n\t\t\t\t\t}\r\n\t    \t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Extracts a parseable phone number including any opening brackets, etc.\r\n * @param  {string} text - Input.\r\n * @return {object} `{ ?number, ?startsAt, ?endsAt }`.\r\n */\r\nexport class PhoneNumberSearch {\r\n\t// Iteration tristate.\r\n\tstate = 'NOT_READY'\r\n\r\n\tconstructor(text, options, metadata) {\r\n\t\tthis.text = text\r\n\t\t// If assigning the `{}` default value is moved to the arguments above,\r\n\t\t// code coverage would decrease for some weird reason.\r\n\t\tthis.options = options || {}\r\n\t\tthis.metadata = metadata\r\n\r\n\t\tthis.regexp = new RegExp(VALID_PHONE_NUMBER_WITH_EXTENSION, 'ig')\r\n\t}\r\n\r\n\tfind() {\r\n\t\tconst matches = this.regexp.exec(this.text)\r\n\t\tif (!matches) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tlet number = matches[0]\r\n\t\tlet startsAt = matches.index\r\n\r\n\t\tnumber = number.replace(WHITESPACE_IN_THE_BEGINNING_PATTERN, '')\r\n\t\tstartsAt += matches[0].length - number.length\r\n\t\t// Fixes not parsing numbers with whitespace in the end.\r\n\t\t// Also fixes not parsing numbers with opening parentheses in the end.\r\n\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/252\r\n\t\tnumber = number.replace(PUNCTUATION_IN_THE_END_PATTERN, '')\r\n\r\n\t\tnumber = parsePreCandidate(number)\r\n\r\n\t\tconst result = this.parseCandidate(number, startsAt)\r\n\t\tif (result) {\r\n\t\t\treturn result\r\n\t\t}\r\n\r\n\t\t// Tail recursion.\r\n\t\t// Try the next one if this one is not a valid phone number.\r\n\t\treturn this.find()\r\n\t}\r\n\r\n\tparseCandidate(number, startsAt) {\r\n\t\tif (!isValidPreCandidate(number, startsAt, this.text)) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// Don't parse phone numbers which are non-phone numbers\r\n\t\t// due to being part of something else (e.g. a UUID).\r\n\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/213\r\n\t\t// Copy-pasted from Google's `PhoneNumberMatcher.js` (`.parseAndValidate()`).\r\n\t\tif (!isValidCandidate(number, startsAt, this.text, this.options.extended ? 'POSSIBLE' : 'VALID')) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// // Prepend any opening brackets left behind by the\r\n\t\t// // `PHONE_NUMBER_START_PATTERN` regexp.\r\n\t\t// const text_before_number = text.slice(this.searching_from, startsAt)\r\n\t\t// const full_number_starts_at = text_before_number.search(BEFORE_NUMBER_DIGITS_PUNCTUATION)\r\n\t\t// if (full_number_starts_at >= 0)\r\n\t\t// {\r\n\t\t// \tnumber   = text_before_number.slice(full_number_starts_at) + number\r\n\t\t// \tstartsAt = full_number_starts_at\r\n\t\t// }\r\n\t\t//\r\n\t\t// this.searching_from = matches.lastIndex\r\n\r\n\t\tconst result = parse(number, this.options, this.metadata)\r\n\t\tif (!result.phone) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tresult.startsAt = startsAt\r\n\t\tresult.endsAt = startsAt + number.length\r\n\t\treturn result\r\n\t}\r\n\r\n\thasNext() {\r\n\t\tif (this.state === 'NOT_READY') {\r\n\t\t\tthis.last_match = this.find()\r\n\t\t\tif (this.last_match) {\r\n\t\t\t\tthis.state = 'READY'\r\n\t\t\t} else {\r\n\t\t\t\tthis.state = 'DONE'\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this.state === 'READY'\r\n\t}\r\n\r\n\tnext() {\r\n\t\t// Check the state and find the next match as a side-effect if necessary.\r\n\t\tif (!this.hasNext()) {\r\n\t\t\tthrow new Error('No next element')\r\n\t\t}\r\n\t\t// Don't retain that memory any longer than necessary.\r\n\t\tconst result = this.last_match\r\n\t\tthis.last_match = null\r\n\t\tthis.state = 'NOT_READY'\r\n\t\treturn result\r\n\t}\r\n}"]},"metadata":{},"sourceType":"module"}